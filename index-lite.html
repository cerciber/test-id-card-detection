<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Detector de Documentos - Lite</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    }
    
    #video {
      display: none;
    }
    
    #canvas {
      position: fixed;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      object-fit: contain;
      background: #000;
    }
    
    #status {
      position: fixed;
      top: 20px;
      left: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      text-align: center;
      border: 2px solid rgba(255, 255, 255, 0.3);
      z-index: 20;
      transition: all 0.3s ease;
    }
    
    #status.detected {
      background: rgba(0, 200, 0, 0.85);
      border-color: rgba(0, 255, 0, 0.8);
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
    }
    
    #captureBtn {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: white;
      border: 5px solid rgba(255, 255, 255, 0.8);
      cursor: pointer;
      z-index: 20;
      transition: all 0.2s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    }
    
    #captureBtn:active {
      transform: translateX(-50%) scale(0.9);
    }
    
    #captureBtn.ready {
      background: #00ff00;
      border-color: #00ff00;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7);
      }
      50% {
        box-shadow: 0 0 0 15px rgba(0, 255, 0, 0);
      }
    }
    
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="loading">Iniciando cámara...</div>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>
  <div id="status">Coloca el documento dentro del marco</div>
  <button id="captureBtn"></button>
  
  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const status = document.getElementById('status');
    const captureBtn = document.getElementById('captureBtn');
    const loading = document.getElementById('loading');
    
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    let isProcessing = false;
    let documentDetected = false;
    let stream = null;
    
    // Configuración
    const CONFIG = {
      DETECTION_THRESHOLD: 0.15,  // Umbral de detección de bordes
      MIN_BRIGHTNESS_DIFF: 20,    // Diferencia mínima de brillo para considerar un borde
      SAMPLE_POINTS: 30,          // Puntos a muestrear en cada lado
      FRAME_SKIP: 2,              // Procesar cada N frames
      GUIDE_MARGIN: 0.08,         // Margen de la guía (8%)
      DOCUMENT_RATIO: 1.586       // Ratio ID card (CR80: 85.6 × 53.98mm)
    };
    
    let frameCount = 0;
    
    // Iniciar cámara
    async function startCamera() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          }
        });
        
        video.srcObject = stream;
        
        video.addEventListener('loadedmetadata', () => {
          loading.style.display = 'none';
          setupCanvas();
          requestAnimationFrame(processFrame);
        });
      } catch (err) {
        loading.textContent = 'Error: No se puede acceder a la cámara';
        console.error('Error accessing camera:', err);
      }
    }
    
    function setupCanvas() {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    }
    
    function processFrame() {
      frameCount++;
      
      // Dibujar video en canvas
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      // Procesar detección cada N frames
      if (frameCount % CONFIG.FRAME_SKIP === 0) {
        detectDocument();
      }
      
      // Dibujar guía y overlay en el mismo canvas
      drawOverlay();
      
      requestAnimationFrame(processFrame);
    }
    
    function detectDocument() {
      const w = canvas.width;
      const h = canvas.height;
      
      // Calcular área de guía (donde debería estar el documento)
      const guideW = w * (1 - CONFIG.GUIDE_MARGIN * 2);
      const guideH = guideW / CONFIG.DOCUMENT_RATIO;
      const guideX = (w - guideW) / 2;
      const guideY = (h - guideH) / 2;
      
      // Obtener datos de imagen
      const imageData = ctx.getImageData(0, 0, w, h);
      const data = imageData.data;
      
      // Detectar bordes en cada lado del área de guía
      const edgeScores = {
        top: detectEdgeHorizontal(data, w, guideX, guideY, guideW, -1),
        bottom: detectEdgeHorizontal(data, w, guideX, guideY + guideH, guideW, 1),
        left: detectEdgeVertical(data, w, guideX, guideY, guideH, -1),
        right: detectEdgeVertical(data, w, guideX + guideW, guideY, guideH, 1)
      };
      
      // Contar lados detectados
      const threshold = CONFIG.DETECTION_THRESHOLD;
      const detectedSides = [];
      
      if (edgeScores.top > threshold) detectedSides.push('Arriba');
      if (edgeScores.bottom > threshold) detectedSides.push('Abajo');
      if (edgeScores.left > threshold) detectedSides.push('Izquierda');
      if (edgeScores.right > threshold) detectedSides.push('Derecha');
      
      documentDetected = detectedSides.length === 4;
      
      // Actualizar estado
      if (documentDetected) {
        status.textContent = '✓ DOCUMENTO DETECTADO - Listo para capturar';
        status.classList.add('detected');
        captureBtn.classList.add('ready');
      } else if (detectedSides.length > 0) {
        status.textContent = `Detectado: ${detectedSides.join(', ')}`;
        status.classList.remove('detected');
        captureBtn.classList.remove('ready');
      } else {
        status.textContent = 'Coloca el documento dentro del marco';
        status.classList.remove('detected');
        captureBtn.classList.remove('ready');
      }
    }
    
    // Detectar borde horizontal (arriba o abajo)
    function detectEdgeHorizontal(data, width, x, y, len, direction) {
      let edgeStrength = 0;
      const step = len / CONFIG.SAMPLE_POINTS;
      const checkDist = 15; // Píxeles a comparar
      
      for (let i = 0; i < CONFIG.SAMPLE_POINTS; i++) {
        const px = Math.floor(x + i * step);
        const py = Math.floor(y);
        
        const inside = py + direction * checkDist;
        
        if (inside < 0 || inside >= canvas.height || px < 0 || px >= width) continue;
        
        const idx1 = (py * width + px) * 4;
        const idx2 = (inside * width + px) * 4;
        
        const brightness1 = (data[idx1] + data[idx1 + 1] + data[idx1 + 2]) / 3;
        const brightness2 = (data[idx2] + data[idx2 + 1] + data[idx2 + 2]) / 3;
        
        const diff = Math.abs(brightness1 - brightness2);
        
        if (diff > CONFIG.MIN_BRIGHTNESS_DIFF) {
          edgeStrength++;
        }
      }
      
      return edgeStrength / CONFIG.SAMPLE_POINTS;
    }
    
    // Detectar borde vertical (izquierda o derecha)
    function detectEdgeVertical(data, width, x, y, len, direction) {
      let edgeStrength = 0;
      const step = len / CONFIG.SAMPLE_POINTS;
      const checkDist = 15; // Píxeles a comparar
      
      for (let i = 0; i < CONFIG.SAMPLE_POINTS; i++) {
        const px = Math.floor(x);
        const py = Math.floor(y + i * step);
        
        const inside = px + direction * checkDist;
        
        if (inside < 0 || inside >= width || py < 0 || py >= canvas.height) continue;
        
        const idx1 = (py * width + px) * 4;
        const idx2 = (py * width + inside) * 4;
        
        const brightness1 = (data[idx1] + data[idx1 + 1] + data[idx1 + 2]) / 3;
        const brightness2 = (data[idx2] + data[idx2 + 1] + data[idx2 + 2]) / 3;
        
        const diff = Math.abs(brightness1 - brightness2);
        
        if (diff > CONFIG.MIN_BRIGHTNESS_DIFF) {
          edgeStrength++;
        }
      }
      
      return edgeStrength / CONFIG.SAMPLE_POINTS;
    }
    
    function drawOverlay() {
      const w = canvas.width;
      const h = canvas.height;
      
      // Área de guía
      const guideW = w * (1 - CONFIG.GUIDE_MARGIN * 2);
      const guideH = guideW / CONFIG.DOCUMENT_RATIO;
      const guideX = (w - guideW) / 2;
      const guideY = (h - guideH) / 2;
      
      // Oscurecer área fuera de la guía
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, w, guideY); // Arriba
      ctx.fillRect(0, guideY + guideH, w, h - guideY - guideH); // Abajo
      ctx.fillRect(0, guideY, guideX, guideH); // Izquierda
      ctx.fillRect(guideX + guideW, guideY, w - guideX - guideW, guideH); // Derecha
      
      // Dibujar marco de guía
      const cornerLen = 40;
      const lineWidth = 4;
      
      ctx.strokeStyle = documentDetected ? '#00ff00' : '#ffffff';
      ctx.lineWidth = lineWidth;
      ctx.lineCap = 'round';
      
      // Esquinas
      const corners = [
        { x: guideX, y: guideY },                    // Top-left
        { x: guideX + guideW, y: guideY },           // Top-right
        { x: guideX, y: guideY + guideH },           // Bottom-left
        { x: guideX + guideW, y: guideY + guideH }   // Bottom-right
      ];
      
      corners.forEach((corner, idx) => {
        ctx.beginPath();
        
        if (idx === 0) { // Top-left
          ctx.moveTo(corner.x, corner.y + cornerLen);
          ctx.lineTo(corner.x, corner.y);
          ctx.lineTo(corner.x + cornerLen, corner.y);
        } else if (idx === 1) { // Top-right
          ctx.moveTo(corner.x - cornerLen, corner.y);
          ctx.lineTo(corner.x, corner.y);
          ctx.lineTo(corner.x, corner.y + cornerLen);
        } else if (idx === 2) { // Bottom-left
          ctx.moveTo(corner.x, corner.y - cornerLen);
          ctx.lineTo(corner.x, corner.y);
          ctx.lineTo(corner.x + cornerLen, corner.y);
        } else if (idx === 3) { // Bottom-right
          ctx.moveTo(corner.x - cornerLen, corner.y);
          ctx.lineTo(corner.x, corner.y);
          ctx.lineTo(corner.x, corner.y - cornerLen);
        }
        
        ctx.stroke();
      });
      
      // Animación cuando está detectado
      if (documentDetected) {
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.lineWidth = 2;
        ctx.strokeRect(guideX, guideY, guideW, guideH);
      }
    }
    
    // Capturar imagen
    captureBtn.addEventListener('click', () => {
      if (!documentDetected) return;
      
      // Crear canvas temporal para la captura
      const captureCanvas = document.createElement('canvas');
      const captureCtx = captureCanvas.getContext('2d');
      
      // Calcular área de corte
      const w = canvas.width;
      const h = canvas.height;
      const guideW = w * (1 - CONFIG.GUIDE_MARGIN * 2);
      const guideH = guideW / CONFIG.DOCUMENT_RATIO;
      const guideX = (w - guideW) / 2;
      const guideY = (h - guideH) / 2;
      
      // Configurar canvas de captura
      captureCanvas.width = guideW;
      captureCanvas.height = guideH;
      
      // Copiar región del documento
      captureCtx.drawImage(
        canvas,
        guideX, guideY, guideW, guideH,
        0, 0, guideW, guideH
      );
      
      // Descargar imagen
      captureCanvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `documento_${Date.now()}.jpg`;
        a.click();
        URL.revokeObjectURL(url);
        
        // Feedback visual
        status.textContent = '✓ Imagen capturada';
        setTimeout(() => {
          status.textContent = 'Coloca el documento dentro del marco';
        }, 2000);
      }, 'image/jpeg', 0.95);
    });
    
    // Iniciar
    startCamera();
  </script>
</body>
</html>

